# Poluhedral Model

## 5.1 Main Concepts
多面体模型是一段代码的抽象，它在各种上下文中使用，因此存在于各种变体（incarnation）中。 尽管它们的名称和表示方式可能不同，但它们都有一些共同的概念。

**Instance Set** 

实例集合是所有“动态执行实例”的集合，例如，一段抽象代码中执行运算部分的集合。

**Dependence Relation**

依赖关系是实例集元素之间的二元关系，其中一个实例以某种方式依赖于另一个。可以考虑几种类型的依赖关系，并且一个实例对另一个实例的依赖的确切性质取决于依赖关系的类型。但是，通常依赖关系表示一个实例需要在另一个实例之前执行。

**Schedule**

一个调度关系（schedule）S定义了一个严格的偏序关系（strict partial order）$<_{S}$，比如一个满足反自反性（irreflexive）和传递性（transitive）的关系，对应到instance set上的元素，表示的是这些instance的执行顺序。

虽然一些多面体编译技术仅将多面体模型用于分析目的，但其他人也使用它来转换所考虑的程序片段。这些转换时通过修改调度顺序（schedule）来表达的。生成的调度顺序需要满足如下属性。


---
这里解释一下上面的严格偏序关系


普通的偏序关系满足如下性质：

给定集合S，设$\le$为集合上的二元关系

1. 自反性: $\forall a \in S, a \leq a$
2. 反对称性: $\forall a, b \in S, a \leq b\ and\ b \leq a$ 则a = b
3. 传递性: $\forall a, b, c \in S, a \leq b\ and\ b \leq c$则 $a \leq c$

严格偏序关系

给定一个集合S, < 是集合S上的二元关系，若 < 满足:
1. 反自反性: $\forall a \in S, a \nless a$
2. 反对称性: $\forall a, b \in S, a < b \Rightarrow b \nless a$
3. 传递性:  $\forall a, b, c \in S, a < b\ and\ b < c$则 $a < c$

严格偏序关系对应一个有向无环图


### Definition 5.1 (Valid Schedule)
设D为依赖关系（dependence relation），表示第一个实例（instance）需要在第二个实例之前执行。设S表示一个调度顺序。调度顺序为一个合理的调度（valid schedule）时，满足依赖关系D，即：

$D \subseteq (<_{S})$

为了满足实例自身的依赖，该条件可以放宽到如下：

$D \backslash 1_{dom\ D} \subseteq (<_{S})$

另外一个常用的抽象关系时访问关系（access relation）。该关系将实例集合的元素映射到某个数据集合的元素，并表示实例集合给定的元素可以访问那些数据元素。

在`iscc`中，`parse_file`操作可以用来从C语言的源码当中提取部分多面体模型。特别是，该操作从源码中第一个最合适的区域中提取出一个多面体模型。该操作以源文件的名字的字符串作为输入，并返回一个包含实例结合的列表（见5.2 Instance Set），must-write关系，may-write关系，may-read关系（见5.3 Acess Relation），以及一个原始调度表示（见5.6 Schedule）。

pet的`pet_scop_extract_from_C_source`函数可以用用来从一个C语言的源码中的一个指定的函数中提取多面体模型。尤其是，从该函数的第一个合适区域中提取`pet_scop`形式的多面体模型。该函数通过`python`的接口导出到`pet`。使用`pet_scop_get_schedule`函数可以用来从`pet_scope`中提取调度。函数`pet_scop_get_instance_set`可以用来从`pet_scop`中提取实例集合。一下函数可以用来提取访问关系（access relation）。
- pet_scop_get_may_read
- pet_scop_get_may_writes
- pet_scop_get_must_writes

## 5.2 Instance Set
### 5.2.1 Definition and Representation

### Definition 5.2 (Instance Set)
实例集合是所有动态执行实例的集合。

动态执行实例通常以组（groups）的形式出现，这些组对应于所表示的程序中的代码片段。组中的不同实例对应于运行时相应代码段的不同执行（distinct executions）。如果程序以源代码形式进行分析和/或转换，那么这些组通常是被分析代码片段中的语句，但是一个语句(statement)也可以分解为几个组，或者相反，一个组也可能包含多个语句。如果程序以编译的形式被分析，那么这些组通常对应于编译器内部表示中的基本块。为了简化讨论，比如组（group），无论是否表示一个程序语句（statement)，一个基本块或者是一些其它的概念，全部统称为多面体语句（polyhedral statement）。

多面体语句的概念的更多细节会在5.8 中的多面体语句中讨论。

通过在每个元素的名称中编码多面体语句并在其整数值中编码多面体语句的动态实例，可以将实例集表示为 Presburger 集。尤其是，如果一个多面体语句嵌套n层循环，那么这个动态实例通常（不是必须的）会表示成n个整数值，每个整数值表示一个循环的迭代数。应该注意，实例集元素中的这些整数序列仅用于识别不同的动态实例，并且它们并不暗示任何特定的执行顺序。也要注意，如果一个多面体模型仅被用于分析程序，例如判定程序中的循环属性，那么语句实例和循环迭代之间的映射要么是隐式的（implicit），要么是单独跟踪的（track of separately）。

### Exmaple 5.3
代码片段5.1 计算了两个向量A和B的内积，A和B的向量长度是100。在该程序段中有两个程序语句（program statements），一个用标签S标记，另一个用标签T。将这两个程序语句看成**多面体语句**。在该代码片段的执行阶段，标记有标签S的语句执行了一次，然而标记有标签T的语句执行了100次。这100个循环当中，在运行期间每一个都可以用循环迭代值$i$来表示。即程序片段中的实例可以表示成如下的**实例集合**：

$\{ S[]; T[i] : 0 \leq i < 100 \}$

在分析的程序片段内未修改的程序变量可以用常量符号表示，因为它具有固定（但未知）的值。 这样的变量也称为参数。

![长度为100的两个向量的内积](./5.1.png)

### Example 5.4

代码片段5.2用于计算两个长度为n的A和B的向量的内积。与程序5.1的区别是，5.1部分代码中循环条件的值为100，现在被替换成了一个变量n。因为变量n在程序运行的阶段不会改变，那么该程序段的实例可以通过实例集合表示如下：

$\{S[]; T[i] : 0 \leq i < n\}$

其中n是一个常量符号。

![长度为n的两个向量的内积](./5.2.png)

### Alternative 5.5 (Per-Statement Instance Set)

许多方法不是对包含所有多面体语句的所有实例的某一个实例集合进行操作的，而是为每一个多面体语句单独维护一个实例集合。


### Alternative 5.6 (Instance Set Name)

实例集中有很多常用的名称（通常是每个语句），包括迭代域（iteration domain）、索引集（index space）和迭代空间（iteration space）。 这些集合的元素通常称为迭代向量（iteration vectors）。

### Alternative 5.7 (Instance Set Representation)\

许多方法对每个语句的实例集使用更严格的表示。特别是，这些表示不允许出现任何整数除法或者量化（quantifier）。部分的表示不允许任何的析取（disjunctions）（包括对连词的否定）。

在后面登录izi当中，一个语句的实例可以表示成一个多面体模型中的整数点。
---
析取这里应该理解成“或”
这里连词比如and 和 or等等。

### Alternative 5.8 (Ordered Instance Set)

有一些计算方式需要将实例集合中的元素set(s)看成是有序的，比如字典序。对这些元素的顺序进行变换相当于修改实例集合set(s)。

### 5.2.2 Input Requirements and Approximations
为了能够准确的表示程序片段中的动态执行实例，该程序片段需要满足一些特定条件。最重要的是，该程序片段需要有静态控制流。即，控制流的需要在编译期就能判定出来，以及其依赖的常量符号值。这意味着控制流不能依赖任何方式的输入数据，而且编译器能够识别出控制了。简单来说，例如，代码不能包含任何goto语句。静态控制流需要允许编译器在编译期准确的判定哪些动态实例会在运行期运行。为了能够将这些实例编码成Presburger 公式的形式，需要添加一个更加严格的约束条件。通常，所有在代码中的条件变量需要都必须是外层循环迭代和参数的仿射表达式（拟仿射表达式），循环迭代的初始值必须是外循环迭代和参数中的仿射表达式（拟仿射表达式），并且循环的步长必须是一个整数常量。

### Example 5.9
见代码段5.3中的增量计算器的伪代码。因为while-loop没有任何显示（explicit）的循环迭代，因此它不能用来表示两个语句在循环中的实例。此外，使用拟仿射表达式来描述循环迭代（以及语句的实例数量）的次数通常来说不太可能。如果程序能够保证是可以停止的，那么代码仍然可能表示成实例集合如下：

$\{ I[]; E1[]; U[i]: 0 \leq i < N; E2[i]: 0 \leq i < N\}$

其中N为一个常量符号，表示循环迭代的次数未知。然而，这样的编码形式仅可能用于一个最外层的while-loop，因为嵌入在其它循环中while-loop的循环迭代通常依赖它外面一层的魂环迭代，因此不能使用一个单一的常量符号来表示。

![增量求解器的伪代码](./5.3.png)

### Exmaple 5.10
考虑代码片段5.4.如果一个变量n是位置的，那么使用循环迭代的值i来表示每个驯化按的实例时，它不可能使用Presburger 公式来描述语句S的实例。（如果变量n的值时已知的，那么可以很简单的使用Presburger 公式来逐个枚举）。在这个例子当中，依旧有可能描述它的实例集合如下：

$\{S[j]: 0 \leq j \leq N \land n \geq 1 \}$
其中N和n是常量符号，且满足$N = \lfloor log_2 n \rfloor \ if \ n \geq 1$。因为n再这个程序段的执行当中不会发生改变，n和N是确定可以作为一个常量符号来使用的。然而，对于一个编译器来讲，去提取这样的一个实例集合是比较困难的。而且，对于n和N的关系无法在实例集合中表达。这意味着在后续的计算当中，编译器会考虑n和N结合的情况，但是在实际中不会发生。最终，i的值在模型的另一部分中需要被$2^j$替换，因为次幂无法在Presburger 公式中产生。

应该注意的是，实例集也可能是在运行时实际执行的实例的过度近似（overapproximation)。大多数分析技术在过度近似方面是安全的，因此如果多面体模型仅用于分析目的，则无需进一步调整。如果多面体模型也用于转换输入程序，则需要采取额外的措施来确保在运行时实际执行的实例集对于输入和输出程序都是相同的。这通常需要保持对多面体语句中额外信息的跟踪。

### 5.2.3 在`pet`中的表示

bla bla

### Example 5.11
bla bla

![inner](./5.5.png)


### Example 5.12
bla bla

### Example 5.13
bla bla

### Example 5.14
bla bla

### Example 5.15
bla bla


## 5.3 Access Relations

### 5.3.1 Definition and Representation

访问关系将实例集的元素映射到该语句访问的数据元素。区分读访问和写访问通常很重要。

### Definition 5.16 (Read Access Relation)
读访问关系将每个动态执行实例映射到的要被动态执行实例读取的元素集合。

### Definition 5.17 (Write Access Relation)
写访关系将每个动态执行实例映射到要被动态执行实例写入的元素的集合。

在一些例子当中，精确的判定被访问元素的集合可能是不可能或者不现实的。而且，即使能够准确的判定访问关系，也可能没办法用Presburger 关系来表示。因此访问权限需要时近似的。
在读访问的情况下，过度近似的分析没有问题。但是在写访问分析时，需要多考虑一些。写访问关系的某些用途，例如，用于计算程序片段可能访问的元素的总集合，也允许过度近似。但是有一些写访问是不允许过度近似的，而是需要一个欠近似分析（underapproximation）。这导致有如下三种类型的访问关系。

### Definitino 5.18 (May-Read Access Relation)
一个may-read访问关系是一个二元关系，该二元关系包含读访问关系作为子集。

### Definitino 5.18 (May-Write Access Relation)
一个may-write访问关系是包含写访问关系作为子集的二元关系。

### Definition 5.20 (Must-Write Access Relation)
一个must-write访问关系是二元关系，它是写访问关系的子集。

请注意，这些定义没有指定关系的确切内容，而只是在may-read和may-write关系的情况下它们至少包含一些元素对，或者它们最多包含一些元素对以防万一的must-write关系。这种灵活性在编译时不清楚给定动态执行实例将访问哪些元素或无法准确表示此信息的情况下很有用。在这些信息可用并且可以准确表示的情况下，可以限制/扩展访问关系以准确地包括那些被访问的数据元素。may-write访问关系等于must-write访问关系。 通常，must-write访问关系是may-write访问关系的子关系。

利用以上的三种访问关系不需要精确的事实，因此可以表示成Presburger 关系。二元关系的domain元素是实例集合的元素，因此有相同的表示。range元素，即访问的数据元素，以类似的方式表示。与实例集的元素一样，这些数据元素以组（groups）（通常是数组）的形式出现，每个元素由组（数组）的名称和组唯一的整数序列（数组的索引）标识 元素）。请注意，由于无法索引标量，因此标量的表示仅由名称组成，并且相应的整数序列为空。即，一个标量看成是一个0维度的数组。

### Example 5.21 
考虑代码片段5.5。访问关系如下面的代码所示。记，may-write访问关系等价于must-write访问关系，因为访问的性质完全可以在编译器决定下来，并且可以用Presburger公式描述。即语句T中访问prod会更新prod，因此将其看作是一个同时拥有读和写的访问。

iscc的例子如下：
```python
P := parse_file " demo / inner .c";
print "Must - write :";
print P [1];
print "May - write :";
print P [2];
print "May - read :";
print P [3];
```
输出为：


```python
"Must - write :"
[n] -> { S[] -> prod []; T[i] -> prod [] : 0 <= i < n }
"May - write :"
[n] -> { S[] -> prod []; T[i] -> prod [] : 0 <= i < n }
"May - read :"
[n] -> { T[i] -> B[i] : 0 <= i < n; T[i] -> A[i] : 0 <= i < n; T[i] -> prod [] : 0 <= i < n }
```

请注意，访问关系不必是函数，因为多个元素被多面体语句的同一实例要么直接或间接有效地访问，或者因为不清楚正在访问哪个元素以便可以访问多个元素。 在最坏的情况下，可以访问整个数组，其中数组元素的集合是从数组的声明中派生的。如果此数组是 C 函数的函数参数，那么通过将 static 关键字放在其他虚拟大小表达式旁边来指定数组在外部维度中的大小也很重要。